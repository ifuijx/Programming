# 编译原理

---

[回到仓库](../README.md)

[TOC]

## 一 概述

买了《编译原理》很久了，一直没有看，最近看了一篇简易实现 `Python` 解释器的文章，感觉很有趣。趁此机会，翻开了《编译原理》，打算好好学习一下。

## 二 引言

现在看了前两章，感觉这本书写得很好，且每句话都是干货。所以我无意于重复这些内容，否则写出来的内容比这本书的内容还要多。因此，我想在这里记录一些读书体会到的内容。

所以，如果想继续读下去，请准备一本《编译原理》书，读完相应章节后再配合阅读本文。

## 三 约定

本文为《编译原理》配合使用，所以需要一些约定。

* 我有所体会的章节会写上内容，没有体会的则跳过。
* 章节按 `页，段，行` 的格式进行导航，或者是 `页，图`、`页，例`

## 四 正文

### 第二章

* 26页，2.2.1

  * 由文法定义，可知，文法关注的序列为一个终结符号序列。这与程序语言是相符合的，程序中的终结符号序列由保留字，常数，变量等组成。而文法定义中的**非终结符号**，则是由**产生式**定义的，通俗地说，产生式就是一个满足一定规则的序列，没有规则的序列是没有意义的。因此，**上下文无关文法**就是要得到一个终结符号序列的产生式解析过程。

* 27页，第一段

  * 注意此处的四个式子
    $$
    \begin{matrix}
        list \to list + digit \\
        list \to list - digit \\
        list \to digit \\
        digit \to \rm {0 \; | \; 1 \; | \; 2 \; | \; 3 \; | \; 4 \; | \; 5 \; | \; 6 \; | \; 7 \; | \; 8 \; | \; 9} \\
    \end{matrix}
    $$
    其中，不止列出的 $10$ 个数字，**$+ \; -$ 也是终结符号**。

* 27页，例2.3

  * 注意此处产生式的巧妙之处
    首先，这里要添加一个空串参数列表，使用的方法是**添加一个非终结符号**。
    $$
    \begin{matrix}
        call \to \rm{id} \; ( \; \it{optparams} \;) \\
        optparams \to params \; | \; \epsilon \\
    \end{matrix}
    $$
    然后，需要单独处理 $params$，使其支持任意参数。
    $$ params \to params \; , \; param \; | \; param$$
    这里是一个递归定义，因此可以支持任意参数。但是，在这里，产生式的头和产生式体的第一个非终结符号是一样的，所以会导致后面提到的左递归现象。一种修正方法是：
    $$ params \to param \; , \; params \; | \; param $$

* 29页，图 2-5

  * 该图考虑到了子节点从左到右构成树的结果，因此绘制成书上的模样。但是这样不便于识别，我在下面进行重新绘制。
    ```
                    list
                 /    |   \
               /      |     \
            list      +    digit
         /    |   \          |
       /      |     \        |
    list      -      digit   2
      |                |
      |                |
    digit              5
      |
      |
      9
    ```
    这个图明确地表示了语法分析树的性质：

    * 根结点的标号为文法的开始符号，此处为 $list$
    * 每个叶子节点的标号为一个终结符号或 $\epsilon$，此处为 `9,-,5,+,2`

    后面的两点我就不赘述了。

* 29页，图 2-6
  这个图显示了文法的二义性，但应该更仔细地探究一番。

  * 比较该文法和例 2.1 的文法，可知，例 2.1 的文法引入了一个新的终结符号 $digit$，该符号的作用是限制 $list$ 的结构，使 $list$ 只能包含一个数字，因此消除了二义性。在这里，再次使用了常见的方法：添加一个非终结符号。
  * 比较这两个语法树，已经知道，第一棵语法树可以由例 2.1 的文法得到，如下：
    $$
    \begin{matrix}
        list \to list \; + \; digit \\
        list \to list \; - \; digit \\
        list \to digit \\
        digit \to \rm {0 \; | \; 1 \; | \; 2 \; | \; 3 \; | \; 4 \; | \; 5 \; | \; 6 \; | \; 7 \; | \; 8 \; | \; 9} \\
    \end{matrix}
    $$
    那么，第二棵语法树应该使用什么样无二义性的文法得到呢？如下：
    $$
    \begin{matrix}
        list \to digit \; + \; list \\
        list \to digit \; - \; list \\
        list \to digit \\
        digit \to \rm {0 \; | \; 1 \; | \; 2 \; | \; 3 \; | \; 4 \; | \; 5 \; | \; 6 \; | \; 7 \; | \; 8 \; | \; 9} \\
    \end{matrix}
    $$
    也就是说，只需要调换前两个产生式中 $list$ 和 $digit$ 的顺序，就能够得到一个向右扩展的语法树。

    更进一步地说，第一个文法含有这种含义：遇到一个长的 $list$，解析方式是先剔除尾部的数字和运算符；第二个文法含有的含义是：遇到一个长的 $list$，解析方式是先剔除首部的数字和运算符。
  * 按照下一小节提出的结合性，还可以分析出，第一种文法属于左结合的方式，第二种文法属于右结合的方式。因为加减运算属于左结合，所以第一种文法符合常规，而第二种文法不是我们想要的。但是，从这里可以比较得出左结合和右结合文法的不同之处。进一步地，如果对赋值运算符改写第二种文法，得到的将是常见的赋值运算符使用方式。